<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KNN算法学霸课堂PK</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Arial', sans-serif;
            background-color: #121212;
            color: #fff;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(255, 0, 255, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(0, 255, 255, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 50% 50%, rgba(255, 255, 0, 0.05) 0%, transparent 25%);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
        }
        
        h1 {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            color: #ffcc00;
            text-shadow: 0 0 10px #ff6600, 0 0 20px #ff6600;
            margin: 20px 0 40px;
            font-size: 2.5rem;
            animation: glow 2s infinite alternate;
            position: relative;
        }
        
        @keyframes glow {
            from {
                text-shadow: 0 0 5px #ffcc00, 0 0 10px #ff6600;
            }
            to {
                text-shadow: 0 0 10px #ffcc00, 0 0 20px #ff6600, 0 0 30px #ff3300;
            }
        }
        
        .game-area {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            position: relative;
        }
        
        .player {
            width: 48%;
            background: rgba(30, 30, 30, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .player.active {
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.7);
            border: 2px solid gold;
            transform: scale(1.02);
        }
        
        .player.waiting {
            opacity: 0.7;
            filter: grayscale(50%);
        }
        
        .player::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border-radius: 20px;
            background: linear-gradient(45deg, #ff0000, #ff7300, #fffb00, #48ff00, #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
            background-size: 400%;
            z-index: -1;
            filter: blur(15px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .player.active::before {
            opacity: 0.3;
            animation: animate-border 20s linear infinite;
        }
        
        @keyframes animate-border {
            0% {
                background-position: 0 0;
            }
            50% {
                background-position: 400% 0;
            }
            100% {
                background-position: 0 0;
            }
        }
        
        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        .player-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4fc3f7;
            text-shadow: 0 0 5px rgba(79, 195, 247, 0.5);
        }
        
        .player-score {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffeb3b;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 20px;
            min-width: 60px;
            text-align: center;
        }
        
        .question-container {
            min-height: 150px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            position: relative;
        }
        
        .question {
            font-size: 1.1rem;
            line-height: 1.5;
            margin-bottom: 15px;
        }
        
        .waiting-message {
            font-size: 1.2rem;
            text-align: center;
            color: #aaa;
            padding: 40px 0;
        }
        
        .options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        
        .option {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .option.selected {
            background: rgba(100, 255, 100, 0.3);
            box-shadow: 0 0 10px rgba(100, 255, 100, 0.5);
        }
        
        .option.correct {
            background: rgba(100, 255, 100, 0.5);
            box-shadow: 0 0 15px rgba(100, 255, 100, 0.7);
        }
        
        .option.incorrect {
            background: rgba(255, 100, 100, 0.5);
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.7);
        }
        
        .controls {
            text-align: center;
            margin-top: 30px;
        }
        
        button {
            background: linear-gradient(45deg, #4fc3f7, #2196f3);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
            font-weight: bold;
            margin: 0 10px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(33, 150, 243, 0.6);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .next-btn {
            background: linear-gradient(45deg, #ff9800, #ff5722);
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
        }
        
        .next-btn:hover {
            box-shadow: 0 8px 20px rgba(255, 87, 34, 0.6);
        }
        
        .feedback {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }
        
        .feedback.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .feedback.correct {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border: 1px solid #4caf50;
        }
        
        .feedback.incorrect {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid #f44336;
        }
        
        .progress-container {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #2196f3);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 5px;
        }
        
        .progress-text {
            text-align: center;
            margin-top: 5px;
            font-size: 0.9rem;
            color: #aaa;
        }
        
        /* 胜利画面样式 */
        .victory-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .victory-screen.show {
            display: flex;
        }
        
        .victory-title {
            font-size: 4rem;
            color: #ffeb3b;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 235, 59, 0.7);
            animation: glow 2s infinite alternate;
        }
        
        .winner-name {
            font-size: 3.5rem;
            color: #4caf50;
            margin: 20px 0;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
            animation: pulse 1.5s infinite;
        }
        
        .draw {
            font-size: 3.5rem;
            color: #ff9800;
            margin: 20px 0;
            text-shadow: 0 0 15px rgba(255, 152, 0, 0.7);
        }
        
        .final-scores {
            display: flex;
            justify-content: center;
            gap: 50px;
            margin: 30px 0;
        }
        
        .player-final-score {
            text-align: center;
        }
        
        .player-final-name {
            font-size: 1.8rem;
            color: #4fc3f7;
            margin-bottom: 10px;
        }
        
        .player-final-points {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffeb3b;
        }
        
        .victory-message {
            font-size: 1.5rem;
            color: #ff9800;
            margin: 20px 0;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
        }
        
        .restart-game-btn {
            background: linear-gradient(45deg, #4fc3f7, #2196f3);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(33, 150, 243, 0.5);
            font-weight: bold;
            margin-top: 30px;
        }
        
        .restart-game-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(33, 150, 243, 0.7);
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00;
            border-radius: 50%;
            animation: confetti-fall 5s linear forwards;
        }
        
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }
        
        .floating {
            position: absolute;
            animation: floating 3s ease-in-out infinite;
            opacity: 0.7;
            z-index: -1;
        }
        
        @keyframes floating {
            0% {
                transform: translateY(0) rotate(0deg);
            }
            50% {
                transform: translateY(-20px) rotate(10deg);
            }
            100% {
                transform: translateY(0) rotate(0deg);
            }
        }
        
        .python-logo {
            width: 80px;
            height: 80px;
            top: 20px;
            left: 20px;
            animation-delay: 0.2s;
        }
        
        .recursion-icon {
            width: 60px;
            height: 60px;
            bottom: 20px;
            right: 20px;
            animation-delay: 0.4s;
        }
        
        .binary-code {
            position: absolute;
            color: rgba(255, 255, 255, 0.05);
            font-size: 1rem;
            user-select: none;
            z-index: -1;
        }
        
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
            }
            
            .player {
                width: 100%;
                margin-bottom: 20px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .victory-title {
                font-size: 2.5rem;
            }
            
            .winner-name, .draw {
                font-size: 2rem;
            }
            
            .player-final-name {
                font-size: 1.5rem;
            }
            
            .player-final-points {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>KNN算法学霸课堂PK</h1>
        
        <div class="game-area">
            <div class="player" id="player1">
                <div class="player-header">
                    <div class="player-name">玩家1</div>
                    <div class="player-score" id="score1">0</div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar" id="progress1"></div>
                </div>
                <div class="progress-text" id="progress-text1">第1题/共10题</div>
                <div class="question-container">
                    <div class="question" id="question1"></div>
                    <div class="options" id="options1"></div>
                    <div class="waiting-message" id="waiting1" style="display: none;">等待玩家2作答...</div>
                </div>
                <div class="feedback" id="feedback1"></div>
            </div>
            
            <div class="player" id="player2">
                <div class="player-header">
                    <div class="player-name">玩家2</div>
                    <div class="player-score" id="score2">0</div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar" id="progress2"></div>
                </div>
                <div class="progress-text" id="progress-text2">第1题/共10题</div>
                <div class="question-container">
                    <div class="question" id="question2"></div>
                    <div class="options" id="options2"></div>
                    <div class="waiting-message" id="waiting2" style="display: none;">等待玩家1作答...</div>
                </div>
                <div class="feedback" id="feedback2"></div>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-btn">开始PK</button>
            <button id="next-btn" class="next-btn" disabled>下一题</button>
        </div>
    </div>
    
    <!-- 胜利画面 -->
    <div class="victory-screen" id="victory-screen">
        <h2 class="victory-title">比赛结果</h2>
        <div id="winner-display"></div>
        <div class="final-scores">
            <div class="player-final-score">
                <div class="player-final-name">玩家1</div>
                <div class="player-final-points" id="final-score1">0</div>
            </div>
            <div class="player-final-score">
                <div class="player-final-name">玩家2</div>
                <div class="player-final-points" id="final-score2">0</div>
            </div>
        </div>
        <div class="victory-message" id="victory-message"></div>
        <button class="restart-game-btn" id="restart-game-btn">再来一局</button>
    </div>
    
    
    <!-- 二进制背景代码 -->
    <div class="binary-code" style="top: 10%; left: 5%;">101010</div>
    <div class="binary-code" style="top: 30%; right: 10%;">110011</div>
    <div class="binary-code" style="bottom: 20%; left: 15%;">100110</div>
    <div class="binary-code" style="bottom: 40%; right: 20%;">111000</div>
    
    <script>
        // 题目数据 - 合并两套题目并随机分配
        const allQuestions = [
            // 第一套题目
            {
                question: "张阿姨想用机器分拣成熟和未成熟的番茄，以下哪个特征是机器最容易识别的？",
                options: ["番茄的气味", "番茄的颜色（RGB值）", "番茄的重量", "番茄的形状"],
                answer: 1,
                explanation: "机器通过RGB值量化颜色，而气味、形状等难以直接测量。"
            },
            {
                question: "KNN算法的第一步是什么？",
                options: ["训练模型", "预测结果", "采集数据", "计算距离"],
                answer: 2,
                explanation: "机器学习需先采集数据，才能训练和预测。"
            },
            {
                question: "以下哪项是KNN算法中“距离计算”的常用方法？",
                options: ["计算颜色差异","欧氏距离","数数量","随机猜测"],
                answer: 1,
                explanation: "欧氏距离是KNN中计算多维空间距离的标准方法。"
            },
            {
                question: "KNN算法中，待测番茄的分类结果取决于什么？",
                options: ["所有番茄的平均颜色","距离最近的K个邻居的类别","番茄的大小","番茄的硬度"],
                answer: 1,
                explanation: "KNN根据K个最近邻的多数类别决定分类结果。"
            },
            {
                question: "小明的KNN模型用颜色（R值）和大小（直径）分类番茄，以下哪种情况可能导致分类错误？",
                options: ["成熟和未成熟番茄的R值差异明显","成熟和未成熟番茄的直径几乎相同","数据标注错误","以上都可能"],
                answer: 3,
                explanation: "直径无区分度（B）、标注错误（C）均会影响分类准确性。"
            },
            {
                question: "以下哪组K值设置是合理的？",
                options: ["K=1（样本总数100）","K=50（样本总数100）","K=10（样本总数100）","K=4（样本总数100）"],
                answer: 2,
                explanation: "K=10避免过拟合（K太小）或忽略局部特征（K太大）。"
            },
            {
                question: "若KNN分类结果不稳定（同一番茄有时判红有时判绿），如何改进？",
                options: ["增加样本数量","调整K值为奇数","检查特征是否合理","以上全部"],
                answer: 3,
                explanation: "不稳定性可能由样本、K值、特征共同导致，需综合改进。"
            },
            {
                question: "若KNN模型在番茄分拣中误将黄色番茄分类为成熟，可能的原因是？① 训练数据中黄色番茄样本过少② K值过小导致过拟合③ 未将颜色和形状特征结合使用",
                options: ["仅①","①和②","②和③","①、②和③"],
                answer: 3,
                explanation: "数据不足（①）、K值问题（②）、特征选择不当（③）均可能导致误分类，需综合关联分析。"
            },
            {
                question: "KNN算法还可用于以下哪种场景？",
                options: ["根据天气数据预测明天是否下雨","根据身高体重判断性别","根据电影评分推荐相似影片","以上全部"],
                answer: 3,
                explanation: "KNN适用于分类（B）、回归（A）、推荐（C）等多种任务。"
            },
            {
                question: "KNN算法在医疗诊断中可能存在什么风险？",
                options: ["样本偏差导致误诊","计算速度慢","需要大量数据","以上全部"],
                answer: 3,
                explanation: "医疗数据偏差（A）、实时性（B）、数据量（C）均为潜在问题。"
            },
            // 第二套题目
            {
                question: "以下哪句话可以概括KNN算法的思想？",
                options: ["“一分耕耘，一分收获”"," “近朱者赤，近墨者黑”","“条条大路通罗马”","“熟能生巧”"],
                answer: 1,
                explanation: "KNN通过“邻居”的类别判断样本类别，与B含义一致。"
            },
            {
                question: "以下哪项是机器学习中“特征”的含义？",
                options: ["数据样本的标签","数据的可视化图表","描述数据的属性或变量（如颜色、大小）","算法的计算速度"],
                answer: 2,
                explanation: "特征是描述数据的属性（如RGB值、重量），而非标签或算法性能。"
            },
            {
                question: "如果计算机用RGB值判断番茄是否成熟，以下哪个番茄的R值可能最高？",
                options: ["绿色未成熟番茄","红色成熟番茄","黄色番茄","紫色番茄"],
                answer: 1,
                explanation: "R值代表红色分量，红色番茄的R值最高。"
            },
            {
                question: "在KNN算法中，若两个番茄的RGB值分别为(255,0,0)和(0,255,0)，它们的颜色差异主要由哪种距离度量？",
                options: ["曼哈顿距离","欧氏距离","余弦相似度","汉明距离"],
                answer: 1,
                explanation: "欧氏距离是KNN中衡量多维空间两点距离的标准方法。"
            },
            {
                question: "在散点图中，横轴为R值，纵轴为G值，以下哪种分布最适合用KNN分类？",
                options: ["红点和绿点完全混合","红点集中在左上，绿点在右下","所有点颜色相同","点随机分布"],
                answer: 1,
                explanation: "红点和绿点分簇明显时，KNN分类效果最好。"
            },
            {
                question: "小华的KNN模型用颜色（R值）和重量分类番茄，以下哪种情况会提高分类准确率？",
                options: ["成熟番茄的R值显著高于未成熟番茄，且重量差异明显","成熟和未成熟番茄的R值相同","仅重量有差异，但数据标注错误","R值和重量均无区分度"],
                answer: 0,
                explanation: "需同时满足颜色和重量两个特征具有区分度（A），单一特征无效（B、D）或数据噪声（C）会降低准确率。"
            },
            {
                question: "张阿姨的番茄分拣系统误将红色番茄分类为未成熟，可能的原因是？",
                options: ["样本中红色番茄数据过少","K值设置过大","反光导致R值提取错误","以上全部"],
                answer: 3,
                explanation: "数据不足（A）、K值不合理（B）、数据噪声（C）均可能导致误分类。"
            },
            {
                question: "设计KNN分类系统时，以下哪一步骤必须在“距离计算”之前完成？",
                options: ["设置K值","数据标注","模型训练","结果预测"],
                answer: 1,
                explanation: "需先标注数据，才能计算待测样本与已标注数据的距离。"
            },
            {
                question: "在番茄分拣系统中，以下哪种情况最适合使用KNN算法？",
                options: ["需要快速处理数百万张番茄图片","番茄的特征维度超过100个","番茄的成熟度分类边界清晰，且样本量适中","需要实时每秒处理1000个番茄"],
                answer: 2,
                explanation: "KNN适合小规模、低维度、分类边界清晰的数据（C正确）。处理大规模数据（A）或高维度数据（B）时效率低，实时性要求高（D）时计算延迟明显。"
            },
            {
                question: "某公司想用KNN算法实时监测生产线上的水果缺陷，但发现效果不佳。以下改进措施中，最不合理的是？",
                options: ["改用卷积神经网络（CNN）处理图像特征","增加K值以提高稳定性","引入红外传感器补充表面缺陷检测","减少样本数量以降低计算量"],
                answer: 3,
                explanation: "KNN的局限性在于实时性和大数据量（D会加剧问题），应选择更高效算法（A）或补充特征（C），而单纯增加K值（B）可能无法解决根本问题。"
            }
        ];
        
// 游戏状态
        let gameState = {
            currentPlayer: 1, // 当前答题玩家
            player1: {
                score: 0,
                currentQuestion: 0,
                questions: [],
                answered: false
            },
            player2: {
                score: 0,
                currentQuestion: 0,
                questions: [],
                answered: false
            },
            gameStarted: false,
            currentRound: 1 // 当前轮次（从1开始）
        };
        
        // DOM元素
        const player1Element = document.getElementById('player1');
        const player2Element = document.getElementById('player2');
        const question1Element = document.getElementById('question1');
        const question2Element = document.getElementById('question2');
        const options1Element = document.getElementById('options1');
        const options2Element = document.getElementById('options2');
        const waiting1Element = document.getElementById('waiting1');
        const waiting2Element = document.getElementById('waiting2');
        const score1Element = document.getElementById('score1');
        const score2Element = document.getElementById('score2');
        const progress1Element = document.getElementById('progress1');
        const progress2Element = document.getElementById('progress2');
        const progressText1Element = document.getElementById('progress-text1');
        const progressText2Element = document.getElementById('progress-text2');
        const feedback1Element = document.getElementById('feedback1');
        const feedback2Element = document.getElementById('feedback2');
        const startBtn = document.getElementById('start-btn');
        const nextBtn = document.getElementById('next-btn');
        
        // 胜利画面元素
        const victoryScreen = document.getElementById('victory-screen');
        const winnerDisplay = document.getElementById('winner-display');
        const finalScore1Element = document.getElementById('final-score1');
        const finalScore2Element = document.getElementById('final-score2');
        const victoryMessageElement = document.getElementById('victory-message');
        const restartGameBtn = document.getElementById('restart-game-btn');
        
        // 初始化游戏
        function initGame() {
            // 重置游戏状态
            gameState = {
                currentPlayer: 1,
                player1: {
                    score: 0,
                    currentQuestion: 0,
                    questions: [],
                    answered: false
                },
                player2: {
                    score: 0,
                    currentQuestion: 0,
                    questions: [],
                    answered: false
                },
                gameStarted: false,
                currentRound: 0
            };
            
            // 随机分配题目给两位玩家
            const shuffledQuestions = [...allQuestions].sort(() => Math.random() - 0.5);
            gameState.player1.questions = shuffledQuestions.slice(0, 10);
            gameState.player2.questions = shuffledQuestions.slice(10, 20);
            
            // 更新UI
            score1Element.textContent = '0';
            score2Element.textContent = '0';
            progress1Element.style.width = '0%';
            progress2Element.style.width = '0%';
            progressText1Element.textContent = '第1题/共10题';
            progressText2Element.textContent = '第1题/共10题';
            question1Element.textContent = '准备开始...';
            question2Element.textContent = '准备开始...';
            options1Element.innerHTML = '';
            options2Element.innerHTML = '';
            waiting1Element.style.display = 'none';
            waiting2Element.style.display = 'none';
            feedback1Element.textContent = '';
            feedback2Element.textContent = '';
            feedback1Element.className = 'feedback';
            feedback2Element.className = 'feedback';
            
            // 设置玩家高亮
            player1Element.classList.add('active');
            player1Element.classList.remove('waiting');
            player2Element.classList.remove('active');
            player2Element.classList.add('waiting');
            
            // 按钮状态
            startBtn.textContent = '开始PK';
            startBtn.disabled = false;
            nextBtn.disabled = true;
            
            // 隐藏胜利画面
            victoryScreen.classList.remove('show');
            
            // 显示游戏区域
            document.querySelector('.container').style.display = 'block';
        }
        
        // 开始游戏
        function startGame() {
            gameState.gameStarted = true;
            gameState.currentRound = 1; // 第一轮
            startBtn.disabled = true;
            nextBtn.disabled = true;
            
            // 显示第一个问题（玩家1先答题）
            showQuestion(1, 0); // 玩家1答第1题
            showWaitingMessage(2);
        }
        
        // 显示问题
        function showQuestion(player, questionIndex) {
            const playerData = player === 1 ? gameState.player1 : gameState.player2;
            const questionElement = player === 1 ? question1Element : question2Element;
            const optionsElement = player === 1 ? options1Element : options2Element;
            const waitingElement = player === 1 ? waiting1Element : waiting2Element;
            const progressElement = player === 1 ? progress1Element : progress2Element;
            const progressTextElement = player === 1 ? progressText1Element : progressText2Element;
            
            const question = playerData.questions[questionIndex];
            questionElement.textContent = question.question;
            
            // 更新进度条
            progressElement.style.width = `${((questionIndex + 1) / playerData.questions.length) * 100}%`;
            progressTextElement.textContent = `第${questionIndex + 1}题/共${playerData.questions.length}题`;
            
            // 生成选项
            optionsElement.innerHTML = '';
            question.options.forEach((option, index) => {
                const optionElement = document.createElement('div');
                optionElement.className = 'option';
                optionElement.textContent = `${String.fromCharCode(65 + index)}. ${option}`;
                optionElement.dataset.index = index;
                optionElement.addEventListener('click', () => selectAnswer(player, index));
                optionsElement.appendChild(optionElement);
            });
            
            // 显示选项，隐藏等待消息
            optionsElement.style.display = 'grid';
            waitingElement.style.display = 'none';
            
            // 重置回答状态
            playerData.answered = false;
            
            // 设置当前玩家高亮
            if (player === 1) {
                player1Element.classList.add('active');
                player1Element.classList.remove('waiting');
                player2Element.classList.remove('active');
                player2Element.classList.add('waiting');
            } else {
                player1Element.classList.remove('active');
                player1Element.classList.add('waiting');
                player2Element.classList.add('active');
                player2Element.classList.remove('waiting');
            }
        }
        
        // 显示等待消息
        function showWaitingMessage(player) {
            const questionElement = player === 1 ? question1Element : question2Element;
            const optionsElement = player === 1 ? options1Element : options2Element;
            const waitingElement = player === 1 ? waiting1Element : waiting2Element;
            
            questionElement.textContent = '';
            optionsElement.style.display = 'none';
            waitingElement.style.display = 'block';
        }
        
        // 选择答案
        function selectAnswer(player, optionIndex) {
            if (!gameState.gameStarted) return;
            
            const playerData = player === 1 ? gameState.player1 : gameState.player2;
            if (playerData.answered) return;
            
            const currentQuestion = playerData.questions[playerData.currentQuestion];
            const optionsElement = player === 1 ? options1Element : options2Element;
            const feedbackElement = player === 1 ? feedback1Element : feedback2Element;
            const scoreElement = player === 1 ? score1Element : score2Element;
            
            // 标记选中的选项
            const optionElements = optionsElement.querySelectorAll('.option');
            optionElements.forEach((el, idx) => {
                el.classList.remove('selected', 'correct', 'incorrect');
                if (idx === optionIndex) {
                    el.classList.add('selected');
                }
            });
            
            // 检查答案
            const isCorrect = optionIndex === currentQuestion.answer;
            if (isCorrect) {
                playerData.score++;
                scoreElement.textContent = playerData.score;
                
                // 显示正确反馈
                feedbackElement.textContent = '✓ 正确! ' + currentQuestion.explanation;
                feedbackElement.className = 'feedback correct show';
                
                // 添加正确动画
                optionElements[optionIndex].classList.add('correct');
            } else {
                // 显示错误反馈和正确答案
                feedbackElement.textContent = '✗ 错误! 正确答案: ' + String.fromCharCode(65 + currentQuestion.answer) + '. ' + currentQuestion.options[currentQuestion.answer] + ' - ' + currentQuestion.explanation;
                feedbackElement.className = 'feedback incorrect show';
                
                // 标记错误和正确答案
                optionElements[optionIndex].classList.add('incorrect');
                optionElements[currentQuestion.answer].classList.add('correct');
            }
            
            // 标记为已回答
            playerData.answered = true;
            
            // 启用下一题按钮
            nextBtn.disabled = false;
        }
        
        // 下一题
        function nextQuestion() {
            nextBtn.disabled = true;
            
            // 隐藏反馈
            feedback1Element.classList.remove('show');
            feedback2Element.classList.remove('show');
            
            // 更新当前轮次
            gameState.currentRound++;
            
            // 切换当前玩家
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            
            // 计算当前问题索引（每个玩家独立计算）
            if (gameState.currentPlayer === 1) {
                // 玩家1的当前题目索引 = (当前轮次-1)/2 取整
                gameState.player1.currentQuestion = Math.floor((gameState.currentRound - 1) / 2);
            } else {
                // 玩家2的当前题目索引 = (当前轮次-1)/2 取整
                gameState.player2.currentQuestion = Math.floor((gameState.currentRound - 1) / 2);
            }
            
            // 检查游戏是否结束（双方都答完所有题目）
            if (gameState.player1.currentQuestion >= gameState.player1.questions.length && 
                gameState.player2.currentQuestion >= gameState.player2.questions.length) {
                endGame();
                return;
            }
            
            // 检查当前玩家是否还有题目
            const currentPlayerData = gameState.currentPlayer === 1 ? gameState.player1 : gameState.player2;
            if (currentPlayerData.currentQuestion >= currentPlayerData.questions.length) {
                // 当前玩家没有题目了，直接结束游戏
                endGame();
                return;
            }
            
            // 显示下一题
            if (gameState.currentPlayer === 1) {
                showQuestion(1, gameState.player1.currentQuestion);
                showWaitingMessage(2);
            } else {
                showQuestion(2, gameState.player2.currentQuestion);
                showWaitingMessage(1);
            }
        }
        
        // 结束游戏
        function endGame() {
            // 隐藏游戏区域
            document.querySelector('.container').style.display = 'none';
            
            // 显示最终得分
            finalScore1Element.textContent = gameState.player1.score;
            finalScore2Element.textContent = gameState.player2.score;
            
            // 判断获胜者
            const scoreDiff = Math.abs(gameState.player1.score - gameState.player2.score);
            let winner = null;
            let victoryMsg = '';
            
            if (gameState.player1.score > gameState.player2.score) {
                winner = '玩家1';
                if (scoreDiff >= 5) {
                    victoryMsg = `完胜！领先${scoreDiff}分`;
                } else if (scoreDiff >= 3) {
                    victoryMsg = `优势胜利！领先${scoreDiff}分`;
                } else {
                    victoryMsg = `险胜！领先${scoreDiff}分`;
                }
            } else if (gameState.player2.score > gameState.player1.score) {
                winner = '玩家2';
                if (scoreDiff >= 5) {
                    victoryMsg = `完胜！领先${scoreDiff}分`;
                } else if (scoreDiff >= 3) {
                    victoryMsg = `优势胜利！领先${scoreDiff}分`;
                } else {
                    victoryMsg = `险胜！领先${scoreDiff}分`;
                }
            } else {
                winner = '平局';
                victoryMsg = '双方势均力敌！';
            }
            
            // 更新胜利画面内容
            winnerDisplay.innerHTML = '';
            if (winner === '平局') {
                const drawElement = document.createElement('div');
                drawElement.className = 'draw';
                drawElement.textContent = '平局！';
                winnerDisplay.appendChild(drawElement);
            } else {
                const winnerElement = document.createElement('div');
                winnerElement.className = 'winner-name';
                winnerElement.textContent = `${winner} 获胜！`;
                winnerDisplay.appendChild(winnerElement);
            }
            
            victoryMessageElement.textContent = victoryMsg;
            
            // 显示胜利画面
            victoryScreen.classList.add('show');
            
            // 创建庆祝彩花
            if (winner !== '平局') {
                createConfetti();
            }
        }
        
        // 创建庆祝彩花
        function createConfetti() {
            const colors = ['#ff0000', '#ffcc00', '#00ff00', '#00ccff', '#cc00ff'];
            
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = `${Math.random() * 100}%`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = `${Math.random() * 10 + 5}px`;
                confetti.style.height = `${Math.random() * 10 + 5}px`;
                confetti.style.animationDuration = `${Math.random() * 3 + 2}s`;
                confetti.style.animationDelay = `${Math.random() * 2}s`;
                document.body.appendChild(confetti);
                
                // 移除彩花元素
                setTimeout(() => {
                    confetti.remove();
                }, 5000);
            }
        }
        
        // 事件监听
        startBtn.addEventListener('click', startGame);
        nextBtn.addEventListener('click', nextQuestion);
        restartGameBtn.addEventListener('click', initGame);
        
        // 初始化游戏
        initGame();
    </script>
</body>
</html>
